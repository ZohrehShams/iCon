package icircles.abstractDescription;
/**
 * Tests for @see AbstractBasicRegion.
 *
 * @author Aidan Delaney <aidan@phoric.eu>
 * Copyright (c) 2012
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the iCircles Project.
 */

import java.util.ArrayList;
import java.util.TreeSet;

import org.junit.*;
import org.junit.runner.RunWith;
import static org.junit.Assert.*;
import org.jcheck.*;
import org.jcheck.annotations.Configuration;
import org.jcheck.annotations.Generator;

/**
 * Implements tests for {@link AbstractBasicRegion}.
 *
 * FIXME: We don't do enough testing for passing null values into methods.
 */
@RunWith(org.jcheck.runners.JCheckRunner.class)
public class TestAbstractBasicRegion {

    /**
     * Tests the get method of @link AbstractBasicRegion
     *
     * Creates two @link AbstractBasicRegion from the same @link AbstractCurve set
     * then compares to ensure they're equal.  Then remove one AbstractCurve from
     * one AbstractBasicRegion and recompare for inequality.
     *
     * @param acs The arbitrary length (<= 20) array of arbitrary @link AbstractCurve objects generated by JCheck
     */
    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testGet(AbstractCurve[] acs) {
        if(0 == acs.length) {
	    assertTrue(true);
	    return;
        }

        TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
	    in_set.add(ac);
        }
        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        for(AbstractCurve ac : acs) {
	    in_set.add(ac);
        }

        AbstractBasicRegion abr2 = AbstractBasicRegion.get(in_set);

	assertEquals(abr1, abr2);
	// get one of the AbstractCurves on the outside
	AbstractCurve first = in_set.first();
	abr2 = abr2.moveOutside(first);

	assertFalse("abr1: " + abr1.toString() + "\nabr2: " + abr2.toString() , abr1.equals(abr2));
    }

    /**
     * Test that {@link AbstractBasicRegion #moveOutside} and {@link AbstractBasicRegion #moved_in} are duals of each other.
     *
     */
    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testMoveOutsideMovedIn(AbstractCurve[] acs) {
        if(0 == acs.length) {
	    assertTrue(true);
	    return;
        }

	TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
	    in_set.add(ac);
        }

        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        AbstractCurve first = in_set.first();
	assertEquals(abr1, abr1.moveOutside(first).movedIn(first));
    }

    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testCompareTo(AbstractCurve[] acs) {
        if(0 == acs.length) {
	    assertTrue(true);
	    return;
        }

        TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
	    in_set.add(ac);
        }

        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        for(AbstractCurve ac : acs) {
	    in_set.add(ac);
        }

        AbstractBasicRegion abr2 = AbstractBasicRegion.get(in_set);

	assertEquals(0, abr1.compareTo(abr2));

	AbstractCurve first = in_set.first();
	assertEquals(-1, abr1.moveOutside(first).compareTo(abr2));
	assertEquals(1, abr2.compareTo(abr1.moveOutside(first)));
    }


    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testGetStraddledContour(AbstractCurve[] acs) {
	// need at least two controus for this test
	if(acs.length < 2) {
	    assertTrue(true);
	    return;
	}

        TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
	    in_set.add(ac);
        }

        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        for(AbstractCurve ac : acs) {
	    in_set.add(ac);
        }

        AbstractBasicRegion abr2 = AbstractBasicRegion.get(in_set);

	assertEquals(null, abr1.getStraddledContour(abr2));
	assertEquals(null, abr2.getStraddledContour(abr1));

	// remove a contour from abr2
	AbstractCurve ac = in_set.first();
	abr2 = abr2.moveOutside(ac);

	assertEquals(ac, abr1.getStraddledContour(abr2));
	assertEquals(ac, abr2.getStraddledContour(abr1));

	// remove another contour from abr2
	ac = in_set.last();
	abr2 = abr2.moveOutside(ac);
       	assertEquals(null, abr1.getStraddledContour(abr2));
	assertEquals(null, abr2.getStraddledContour(abr1));
    }

    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testIsLabelEquivalent(AbstractCurve[] acs) {
	// Again, need at least one curve
        if(0 == acs.length) {
	    assertTrue(true);
	    return;
        }

        TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
	    in_set.add(ac);
        }

        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        for(AbstractCurve ac : acs) {
	    in_set.add(ac);
        }

        AbstractBasicRegion abr2 = AbstractBasicRegion.get(in_set);

	assertTrue(abr1.isLabelEquivalent(abr2));

	AbstractCurve first = in_set.first();
	assertFalse(abr1.moveOutside(first).isLabelEquivalent(abr2));
	assertFalse(abr1.isLabelEquivalent(abr2.moveOutside(first)));
    }
}
